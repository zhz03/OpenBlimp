{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OpenBlimp website! Welcome to OpenBlimp's documentation. OpenBlimp is a open source packages to manufacture, build and control your custom blimp from scratch. For normal users, it's easy to build your manual control system by following the step by step process. And for developer users, OpenBlimp also allows users to develop their own autonomous algorithms on the blimp. OpenBlimp is a work in progress. Many features on the roadmap are being continuously developed. We welcome your contribution and please visit our Github repo for latest release. OpenBlimp source code on Github Content Getting Started Blimp System Overview Preparation Quick Start User Tutorial Logic Flow Hardware mapping User interface Developer Tutorial Capability extension Algorithm customization Hardware Hardware Introduction Hardware Manufacture Hardware Assembly Software Manual control Autonomous control Demos Sensors Unit Tests Flying Tests Additional Information About Us Previous resources","title":"Home"},{"location":"#welcome-to-openblimp-website","text":"Welcome to OpenBlimp's documentation. OpenBlimp is a open source packages to manufacture, build and control your custom blimp from scratch. For normal users, it's easy to build your manual control system by following the step by step process. And for developer users, OpenBlimp also allows users to develop their own autonomous algorithms on the blimp. OpenBlimp is a work in progress. Many features on the roadmap are being continuously developed. We welcome your contribution and please visit our Github repo for latest release. OpenBlimp source code on Github","title":"Welcome to OpenBlimp website!"},{"location":"#content","text":"","title":"Content"},{"location":"#getting-started","text":"Blimp System Overview Preparation Quick Start","title":"Getting Started"},{"location":"#user-tutorial","text":"Logic Flow Hardware mapping User interface","title":"User Tutorial"},{"location":"#developer-tutorial","text":"Capability extension Algorithm customization","title":"Developer Tutorial"},{"location":"#hardware","text":"Hardware Introduction Hardware Manufacture Hardware Assembly","title":"Hardware"},{"location":"#software","text":"Manual control Autonomous control","title":"Software"},{"location":"#demos","text":"Sensors Unit Tests Flying Tests","title":"Demos"},{"location":"#additional-information","text":"About Us Previous resources","title":"Additional Information"},{"location":"AboutUs/","text":"About Us This project would not happen if there are no such a wonderful team. Supervisor Dr. Ankur Mehta Core Developers Zhaoliang Zheng Project lead and OpenBlimp Architect Homepage Kamil Auto control and OpenMV cam development Jillian Naldrien Pantig Auto control and system testing Zhiyin Li System testing and blimp manufacturing Warnakulasuriya Shelard R. Fernando Electrical system and system testing Aaron John Sabu Detection algorithms Parth Agrawal Manual control and detection algorithms Tam Hieu Nguyen Blimp manufacturing Other Developers Jiahao Li Ryan Chen Pranav Sankar Srinivasan","title":"About Us"},{"location":"AboutUs/#about-us","text":"This project would not happen if there are no such a wonderful team.","title":"About Us"},{"location":"AboutUs/#supervisor","text":"Dr. Ankur Mehta","title":"Supervisor"},{"location":"AboutUs/#core-developers","text":"Zhaoliang Zheng Project lead and OpenBlimp Architect Homepage Kamil Auto control and OpenMV cam development Jillian Naldrien Pantig Auto control and system testing Zhiyin Li System testing and blimp manufacturing Warnakulasuriya Shelard R. Fernando Electrical system and system testing Aaron John Sabu Detection algorithms Parth Agrawal Manual control and detection algorithms Tam Hieu Nguyen Blimp manufacturing","title":"Core Developers"},{"location":"AboutUs/#other-developers","text":"Jiahao Li Ryan Chen Pranav Sankar Srinivasan","title":"Other Developers"},{"location":"Algo_custom/","text":"Algorithm Customization Communication Sensing algorithms Control algorithms","title":"Algorithm customization"},{"location":"Algo_custom/#algorithm-customization","text":"","title":"Algorithm Customization"},{"location":"Algo_custom/#communication","text":"","title":"Communication"},{"location":"Algo_custom/#sensing-algorithms","text":"","title":"Sensing algorithms"},{"location":"Algo_custom/#control-algorithms","text":"","title":"Control algorithms"},{"location":"Basic_assembly/","text":"Blimp Assembly The blimp overall structure is consist of following parts: Electronics Assembly Here is one example of wiring all electronics together: Overall Assembly","title":"Basic Assembly"},{"location":"Basic_assembly/#blimp-assembly","text":"The blimp overall structure is consist of following parts:","title":"Blimp Assembly"},{"location":"Basic_assembly/#electronics-assembly","text":"Here is one example of wiring all electronics together:","title":"Electronics Assembly"},{"location":"Basic_assembly/#overall-assembly","text":"","title":"Overall Assembly"},{"location":"Blimp_system_overview/","text":"Blimp System Overview For those of you who wants to build and manipulate your own blimp, this will be a best place for you to start! Blimp introduction Due to their ability to neutrally float in the air, lighter-than-air vehicles (LTAVs) had been widely studied and used as research and military platforms for aerial robotics over the last century. As a branch of LTAVs, the indoor airship is gaining increasing attention due to its promising potential for many applications [1]. In the past 20 years, indoor blimps have been developed for infrastructure inspection [2], environmental data collection [3], indoor localization and mapping [4], education and research platforms [5], vision-based human-robot interaction [6], and other activities. While these tasks may also be conducted using unmanned aerial vehicles (UAVs) such as quadrotors, their flight duration time is generally only between 20 to 30 minutes, restricted by the power required for them to hover in air. Quadrotors can also cause safety concerns when they operate in indoor environments with humans due to their relatively high operating speed and high-speed rotating blades. Advantages of blimp There are lots of advantages of using blimps, for example: Long flight time and operation duration in the air Safer to environment and human Energy efficiency Disadvantages of blimp There are also some disadvantages of blimps, for example: \u200b Blimp system architecture Reference [1] Yasmina Bestaoui Sebbane. Lighter than air robots: Guidance and control of autonomous airships, volume 58. Springer Science & Business Media, 2011. [2] Yoshihiro Nitta, Shinsuke Inai, Kunio Matsumura, Masami Ishida, Toshio Onai, and Akira Nishitani. The visual inspection methodology for ceiling utilizing the blimp. Procedia Engineering, 188:256\u2013262, 2017. [3] George Kantor, David Wettergreen, James P Ostrowski, and Sanjiv Singh. Collection of environmental data from an airship platform. In Sensor Fusion and Decentralized Control in Robotic Systems IV, volume 4571, pages 76\u201383. International Society for Optics and Photonics, 2001. [4] J \u0308org M \u0308uller and Wolfram Burgard. Efficient probabilistic localization for autonomous indoor airships using sonar, air flow, and imu sensors. Advanced Robotics, 27(9):711\u2013724, 2013. [5] Gal Gorjup and Minas Liarokapis. A low-cost, open-source, robotic airship for education and research. IEEE Access, 8:70713\u201370721, 2020. [6] N. Yao, E. Anaya, Q. Tao, S. Cho, H. Zheng, and F. Zhang. Monocular vision-based human following on miniature robotic blimp. In 2017 IEEE International Conference on Robotics and Automation (ICRA), pages 3244\u20133249, 2017.","title":"Blimp System Overview"},{"location":"Blimp_system_overview/#blimp-system-overview","text":"For those of you who wants to build and manipulate your own blimp, this will be a best place for you to start!","title":"Blimp System Overview"},{"location":"Blimp_system_overview/#blimp-introduction","text":"Due to their ability to neutrally float in the air, lighter-than-air vehicles (LTAVs) had been widely studied and used as research and military platforms for aerial robotics over the last century. As a branch of LTAVs, the indoor airship is gaining increasing attention due to its promising potential for many applications [1]. In the past 20 years, indoor blimps have been developed for infrastructure inspection [2], environmental data collection [3], indoor localization and mapping [4], education and research platforms [5], vision-based human-robot interaction [6], and other activities. While these tasks may also be conducted using unmanned aerial vehicles (UAVs) such as quadrotors, their flight duration time is generally only between 20 to 30 minutes, restricted by the power required for them to hover in air. Quadrotors can also cause safety concerns when they operate in indoor environments with humans due to their relatively high operating speed and high-speed rotating blades.","title":"Blimp introduction"},{"location":"Blimp_system_overview/#advantages-of-blimp","text":"There are lots of advantages of using blimps, for example: Long flight time and operation duration in the air Safer to environment and human Energy efficiency","title":"Advantages of blimp"},{"location":"Blimp_system_overview/#disadvantages-of-blimp","text":"There are also some disadvantages of blimps, for example: \u200b","title":"Disadvantages of blimp"},{"location":"Blimp_system_overview/#blimp-system-architecture","text":"","title":"Blimp system architecture"},{"location":"Blimp_system_overview/#reference","text":"[1] Yasmina Bestaoui Sebbane. Lighter than air robots: Guidance and control of autonomous airships, volume 58. Springer Science & Business Media, 2011. [2] Yoshihiro Nitta, Shinsuke Inai, Kunio Matsumura, Masami Ishida, Toshio Onai, and Akira Nishitani. The visual inspection methodology for ceiling utilizing the blimp. Procedia Engineering, 188:256\u2013262, 2017. [3] George Kantor, David Wettergreen, James P Ostrowski, and Sanjiv Singh. Collection of environmental data from an airship platform. In Sensor Fusion and Decentralized Control in Robotic Systems IV, volume 4571, pages 76\u201383. International Society for Optics and Photonics, 2001. [4] J \u0308org M \u0308uller and Wolfram Burgard. Efficient probabilistic localization for autonomous indoor airships using sonar, air flow, and imu sensors. Advanced Robotics, 27(9):711\u2013724, 2013. [5] Gal Gorjup and Minas Liarokapis. A low-cost, open-source, robotic airship for education and research. IEEE Access, 8:70713\u201370721, 2020. [6] N. Yao, E. Anaya, Q. Tao, S. Cho, H. Zheng, and F. Zhang. Monocular vision-based human following on miniature robotic blimp. In 2017 IEEE International Conference on Robotics and Automation (ICRA), pages 3244\u20133249, 2017.","title":"Reference"},{"location":"Capability/","text":"Capability extension Shape extension Sensing module extension Control module extension Manual control Code structure \u251c\u2500\u2500\u2500base_station \u2502 \u251c\u2500\u2500\u2500ball_detection \u2502 \u2502 \u251c\u2500\u2500\u2500distance-detection-torch \u2502 \u2502 \u2514\u2500\u2500\u2500model_weights \u2502 \u251c\u2500\u2500\u2500logs \u2502 \u2514\u2500\u2500\u2500pid \u2514\u2500\u2500\u2500feather_board Autonomous control","title":"Capability extension"},{"location":"Capability/#capability-extension","text":"","title":"Capability extension"},{"location":"Capability/#shape-extension","text":"","title":"Shape extension"},{"location":"Capability/#sensing-module-extension","text":"","title":"Sensing module extension"},{"location":"Capability/#control-module-extension","text":"","title":"Control module extension"},{"location":"Capability/#manual-control","text":"","title":"Manual control"},{"location":"Capability/#code-structure","text":"\u251c\u2500\u2500\u2500base_station \u2502 \u251c\u2500\u2500\u2500ball_detection \u2502 \u2502 \u251c\u2500\u2500\u2500distance-detection-torch \u2502 \u2502 \u2514\u2500\u2500\u2500model_weights \u2502 \u251c\u2500\u2500\u2500logs \u2502 \u2514\u2500\u2500\u2500pid \u2514\u2500\u2500\u2500feather_board","title":"Code structure"},{"location":"Capability/#autonomous-control","text":"","title":"Autonomous control"},{"location":"Communication/","text":"Communication network For either remotely control your designed blimp or to communicate all the sensors on the blimp and transmit your signal back to your base station, communication network is critical in blimp development. Here we provide some different solutions. RF WebSocket RF Peer-to-peer WiFi Peer-to-peer Wifi WebSocket","title":"Communication"},{"location":"Communication/#communication-network","text":"For either remotely control your designed blimp or to communicate all the sensors on the blimp and transmit your signal back to your base station, communication network is critical in blimp development. Here we provide some different solutions.","title":"Communication network"},{"location":"Communication/#rf-websocket","text":"","title":"RF WebSocket"},{"location":"Communication/#rf-peer-to-peer","text":"","title":"RF Peer-to-peer"},{"location":"Communication/#wifi-peer-to-peer","text":"","title":"WiFi Peer-to-peer"},{"location":"Communication/#wifi-websocket","text":"","title":"Wifi WebSocket"},{"location":"Design_principle/","text":"Design principle To build a successful blimp, you need to follow some basic design principles. Design principle involves two aspects: Payload estimate and checking: Whether the designed airship can be effectively suspended in the air. Motion primitives checking: Whether the designed blimp can effectively move in the 3D space Please use following checkbox to see if your design satisfy these principles: Principle 1: To allow the designed airship to maintain neutral buoyancy in the air. You need to make sure the following equation satisfied: \\[ F_B - m_{total} = 0 \\] where, \\(F_B\u200b\\) is the buoyancy produced by your designed airship \\(m_{total}\\) is the total lifting capacity of your designed airship \\(m_{total} = m_{elec} + m_{envelop} + m_{sup} + m_{payload}\\) The lifting capacity can be divided into the weight of electronics, balloon envelope(Note: this is not something you can ignore), support materials and payload. Principle 2 : To satisfy the needs of exploring the space, your design needs to satisfy the basic motion primitives: Maintaining forward speed. The blimp should be able to maintain a desired constant forward speed while having zero vertical speed and zero yaw angular speed. Changing altitude: The blimp should be able to ascend or descend to the desired height. Changing orientation: The blimp should be able to spin in place so that its yaw angle can be stabilized at any desired value.","title":"Design Principle"},{"location":"Design_principle/#design-principle","text":"To build a successful blimp, you need to follow some basic design principles. Design principle involves two aspects: Payload estimate and checking: Whether the designed airship can be effectively suspended in the air. Motion primitives checking: Whether the designed blimp can effectively move in the 3D space Please use following checkbox to see if your design satisfy these principles: Principle 1: To allow the designed airship to maintain neutral buoyancy in the air. You need to make sure the following equation satisfied: \\[ F_B - m_{total} = 0 \\] where, \\(F_B\u200b\\) is the buoyancy produced by your designed airship \\(m_{total}\\) is the total lifting capacity of your designed airship \\(m_{total} = m_{elec} + m_{envelop} + m_{sup} + m_{payload}\\) The lifting capacity can be divided into the weight of electronics, balloon envelope(Note: this is not something you can ignore), support materials and payload. Principle 2 : To satisfy the needs of exploring the space, your design needs to satisfy the basic motion primitives: Maintaining forward speed. The blimp should be able to maintain a desired constant forward speed while having zero vertical speed and zero yaw angular speed. Changing altitude: The blimp should be able to ascend or descend to the desired height. Changing orientation: The blimp should be able to spin in place so that its yaw angle can be stabilized at any desired value.","title":"Design principle"},{"location":"Development_logic/","text":"Development Logic For developer who wants to develop your own blimp using our OpenBlimp guideline and framework, we will introduce some key focus on this chapter. Development guideline Overall development framework Communication method Capability extension Algorithm customization Development guideline Blimp development is a complicated work which is highly hardware-software integrated.","title":"Development logic"},{"location":"Development_logic/#development-logic","text":"For developer who wants to develop your own blimp using our OpenBlimp guideline and framework, we will introduce some key focus on this chapter. Development guideline Overall development framework Communication method Capability extension Algorithm customization","title":"Development Logic"},{"location":"Development_logic/#development-guideline","text":"Blimp development is a complicated work which is highly hardware-software integrated.","title":"Development guideline"},{"location":"Hardware/","text":"Hardware Hardware Introduction Hardware Manufacture Hardware Assembly","title":"Hardware"},{"location":"Hardware/#hardware","text":"","title":"Hardware"},{"location":"Hardware/#hardware-introduction","text":"","title":"Hardware Introduction"},{"location":"Hardware/#hardware-manufacture","text":"","title":"Hardware Manufacture"},{"location":"Hardware/#hardware-assembly","text":"","title":"Hardware Assembly"},{"location":"HardwareMapping/","text":"Hardware Mapping Introduction For the blimp system, one important aspect to notice is the mapping between your control and hardware. We design a user interface for normal user to easily control blimps they design. However, to control blimp exactly as expected, users need to build up the correct mapping between control and propulsion system of blimps. To be more specific, what's the right wiring and control mapping as shown below: For example, you want to build a blimp that has 4 motors+propellers output, two specific motors can control the horizontal motion of your blimp and the other two motors need to handle the vertical motion while the horizontal motors should also make your blimp rotate. How do you match your motors with your joystick controller if you need only one joystick to control both horizontal motion and the other joystick to control vertical motion. As we introduced before, we choose Blynk APP as the control interface since it\u2019s a freely available application that anyone could download online. As shown in the figure above, the control panel contains two joysticks to control blimp movement(horizontal and vertical) and one slider to control all motors speed. Installation Step 1: Install Blynk App Follow the instruction in the previous section User interface to setup your Blynk App. Step 2: Upload Arduino program Since the wiring of electronics will directly determine how to manipulate the custom blimp, we provide users ready-to-go low-level Arduino program to handle the wiring and connection between the control board and motor propellers and allows users to re-map the control to the actual propulsion system they design through the terminal panel. Step 3: Input the correct configuration commands through 3-step experiments To find out the correct command that matches the mapping, users need to go over the following three iterations: (Iter. 1) Initialization: Initial command \"1F2B3U4DN\" means that DC motor channel 1 is \"forward\" rotation, channel 2 is \"backward\" rotation, channel 3 is \"upward\" rotation, channel 4 is \"downward\" rotation, and the left and right direction is not confirmed. (Iter. 2) Determine main horizontal and vertical channel: based on the actual propellers rotation and activation situation, use joystick to check if previous command is correct, if not, then change the command to determine the correct horizontal and vertical channel and rotation direction. Command after iteration example: \"1F2F3U4DC1L2R\". The last 5 digits means that horizontal and vertical channel are confirmed using DC motor and assume channel 1 to rotate left and channel 2 to rotate right. (Iter. 3) Determine the rotation channel from previous command: if the previous command is correct then stop. If not, then switch the rotation channel, for example: \"1F2F3U4DC2L1R\". Here are two case study of using \"error and trial\" method to figure out the correct configuration commands:","title":"Hardware mapping"},{"location":"HardwareMapping/#hardware-mapping","text":"","title":"Hardware Mapping"},{"location":"HardwareMapping/#introduction","text":"For the blimp system, one important aspect to notice is the mapping between your control and hardware. We design a user interface for normal user to easily control blimps they design. However, to control blimp exactly as expected, users need to build up the correct mapping between control and propulsion system of blimps. To be more specific, what's the right wiring and control mapping as shown below: For example, you want to build a blimp that has 4 motors+propellers output, two specific motors can control the horizontal motion of your blimp and the other two motors need to handle the vertical motion while the horizontal motors should also make your blimp rotate. How do you match your motors with your joystick controller if you need only one joystick to control both horizontal motion and the other joystick to control vertical motion. As we introduced before, we choose Blynk APP as the control interface since it\u2019s a freely available application that anyone could download online. As shown in the figure above, the control panel contains two joysticks to control blimp movement(horizontal and vertical) and one slider to control all motors speed.","title":"Introduction"},{"location":"HardwareMapping/#installation","text":"Step 1: Install Blynk App Follow the instruction in the previous section User interface to setup your Blynk App. Step 2: Upload Arduino program Since the wiring of electronics will directly determine how to manipulate the custom blimp, we provide users ready-to-go low-level Arduino program to handle the wiring and connection between the control board and motor propellers and allows users to re-map the control to the actual propulsion system they design through the terminal panel. Step 3: Input the correct configuration commands through 3-step experiments To find out the correct command that matches the mapping, users need to go over the following three iterations: (Iter. 1) Initialization: Initial command \"1F2B3U4DN\" means that DC motor channel 1 is \"forward\" rotation, channel 2 is \"backward\" rotation, channel 3 is \"upward\" rotation, channel 4 is \"downward\" rotation, and the left and right direction is not confirmed. (Iter. 2) Determine main horizontal and vertical channel: based on the actual propellers rotation and activation situation, use joystick to check if previous command is correct, if not, then change the command to determine the correct horizontal and vertical channel and rotation direction. Command after iteration example: \"1F2F3U4DC1L2R\". The last 5 digits means that horizontal and vertical channel are confirmed using DC motor and assume channel 1 to rotate left and channel 2 to rotate right. (Iter. 3) Determine the rotation channel from previous command: if the previous command is correct then stop. If not, then switch the rotation channel, for example: \"1F2F3U4DC2L1R\". Here are two case study of using \"error and trial\" method to figure out the correct configuration commands:","title":"Installation"},{"location":"Hardware_intro/","text":"Hardware Introduction As we already introduced in the Blimp System Overview and Preparation , blimp is a relative complex system that requires lots of hardware.","title":"Hardware Introduction"},{"location":"Hardware_intro/#hardware-introduction","text":"As we already introduced in the Blimp System Overview and Preparation , blimp is a relative complex system that requires lots of hardware.","title":"Hardware Introduction"},{"location":"Hardware_manufact/","text":"Blimp Manufacturing 1 Mylar Blimp Envelope The main process of manufacturing a custom Mylar balloon: The post-processing of manufacturing a custom Mylar balloon: 2 Gondola and 3D printed support","title":"Hardware Manufacture"},{"location":"Hardware_manufact/#blimp-manufacturing","text":"","title":"Blimp Manufacturing"},{"location":"Hardware_manufact/#1-mylar-blimp-envelope","text":"The main process of manufacturing a custom Mylar balloon: The post-processing of manufacturing a custom Mylar balloon:","title":"1 Mylar Blimp Envelope"},{"location":"Hardware_manufact/#2-gondola-and-3d-printed-support","text":"","title":"2 Gondola and 3D printed support"},{"location":"How_to_contribute/","text":"How to contribute to this project? To contribute to this repo, there are several things you need to know first. Requirements MkDocs is a static site generator for creating project documentation. The document source code is written in Markdown. After configuration, it can automatically generate a site with a directory structure, which is often used to write technical documents and personal blogs. Installing MkDocs requires Python and Python package manager pip, if you already have Python and pip , open the terminal and execute the following command: pip install mkdocs Note: If you are using Windows, some of the above commands may not work out-of-the-box. A quick solution may be to preface every Python command with python -m like this: powershell python -m pip install mkdocs python -m mkdocs How to git There will be three different branches: main main branch is only for version release, do not work on this branch, contact Zhaoliang(zhz03@g.ucla.edu) if you need to do anything with it. develop develop branch is for development, do not directly work on it. If you need to merge your feature branch to develop , require a pull request before mering. feature/xxx feature/xxx branch is for contributors to commit, make a new feature/xxx branch before you want to edit anything, where xxx is the name of your own part. Activate server locally MkDocs includs a built-in server to preview the current document locally. Under the project directory, execute mkdocs serve to activate the built-in server: mkdocs serve After execution, open the link http://127.0.0.1:8000/ in the browser to see your update, like this: Add new pages To add new pages, all you need to do is to create a Markdown file and put it under the docs directory. Here as an example, we put TO_be_continue.md in to docs directory. Open mkdocs.yml configuration file, and make changes as follows: After save this file, you should be able to see the effect immediately on your browser. To add more content, all you need to do is to edit corresponding markdown files. How simple is that! Build locally To build your site, under your project directory. Open terminal and execute mkdocs build command as below: mkdocs build After this step, you should be able to see a site directory under your project directory, and it contains all your html files. Deploy your website To deploy your website to the git, open terminal and run the following command: mkdocs gh-deploy And you should see the following:","title":"How to contribute"},{"location":"How_to_contribute/#how-to-contribute-to-this-project","text":"To contribute to this repo, there are several things you need to know first.","title":"How to contribute to this project?"},{"location":"How_to_contribute/#requirements","text":"MkDocs is a static site generator for creating project documentation. The document source code is written in Markdown. After configuration, it can automatically generate a site with a directory structure, which is often used to write technical documents and personal blogs. Installing MkDocs requires Python and Python package manager pip, if you already have Python and pip , open the terminal and execute the following command: pip install mkdocs Note: If you are using Windows, some of the above commands may not work out-of-the-box. A quick solution may be to preface every Python command with python -m like this: powershell python -m pip install mkdocs python -m mkdocs","title":"Requirements"},{"location":"How_to_contribute/#how-to-git","text":"There will be three different branches: main main branch is only for version release, do not work on this branch, contact Zhaoliang(zhz03@g.ucla.edu) if you need to do anything with it. develop develop branch is for development, do not directly work on it. If you need to merge your feature branch to develop , require a pull request before mering. feature/xxx feature/xxx branch is for contributors to commit, make a new feature/xxx branch before you want to edit anything, where xxx is the name of your own part.","title":"How to git"},{"location":"How_to_contribute/#activate-server-locally","text":"MkDocs includs a built-in server to preview the current document locally. Under the project directory, execute mkdocs serve to activate the built-in server: mkdocs serve After execution, open the link http://127.0.0.1:8000/ in the browser to see your update, like this:","title":"Activate server locally"},{"location":"How_to_contribute/#add-new-pages","text":"To add new pages, all you need to do is to create a Markdown file and put it under the docs directory. Here as an example, we put TO_be_continue.md in to docs directory. Open mkdocs.yml configuration file, and make changes as follows: After save this file, you should be able to see the effect immediately on your browser. To add more content, all you need to do is to edit corresponding markdown files. How simple is that!","title":"Add new pages"},{"location":"How_to_contribute/#build-locally","text":"To build your site, under your project directory. Open terminal and execute mkdocs build command as below: mkdocs build After this step, you should be able to see a site directory under your project directory, and it contains all your html files.","title":"Build locally"},{"location":"How_to_contribute/#deploy-your-website","text":"To deploy your website to the git, open terminal and run the following command: mkdocs gh-deploy And you should see the following:","title":"Deploy your website"},{"location":"Manual_control/","text":"Template!","title":"Manual Control"},{"location":"Manual_control/#template","text":"","title":"Template!"},{"location":"Preparation/","text":"Hardware Preparation 1 Balloon Envelop For off-the-shelf blimp To use off-the-shelf blimp, we recommend several options that are \u200b (1) Enough payload capability \u200b (2)Safe and reliable envelop The purchase links are shown below: Shark and fish balloon 36'' balloon For DIY To DIY your own custom shape balloon envelop, we also recommend using Mylar as materials. To purchase Mylar, we recommend this Mylar sheet For manufacturing blimp envelop, please check Hardware manufacture 2 Propulsion system For propulsion system, we will try motor+propellers as propulsion solution. You need to prepare the following items: Motors (Both DC or brushless motors would work) For brushless motors, you also need ESC( Electric Speed Controller ) Propellers Motor drivers Here are some examples (different DC motors and propellers combinations): As listed above, the propellers should be compatible with your motor. Here are some links: 3 Control system For control system, we have multiple options for users to decide: NodeMCU ESP8266 Feather board ESP32 Raspberry Pi Zero W 4 Support structure The support structure is for holding all the electronics in their positions. There are two different set of support structure, the first one is the most common one: 3D printed support, and the second one is another form: origami structure. For both 3D-printed structure and origami structure. We provide all their design files for users to print and use for their own blimp. 3D-printed support structure files Origami support structure files 5 Battery and Payloads The battery are critical to the blimp system and often times it can also be considered as one of the payloads on blimp. Something to notice for purchasing batteries: It should be small and light enough It should have big enough current output To understand more knowledge about batteries, please check the link Here are some links for batteries that we recommended: 450mhA batteries","title":"Preparation"},{"location":"Preparation/#hardware-preparation","text":"","title":"Hardware Preparation"},{"location":"Preparation/#1-balloon-envelop","text":"","title":"1 Balloon Envelop"},{"location":"Preparation/#for-off-the-shelf-blimp","text":"To use off-the-shelf blimp, we recommend several options that are \u200b (1) Enough payload capability \u200b (2)Safe and reliable envelop The purchase links are shown below: Shark and fish balloon 36'' balloon","title":"For off-the-shelf blimp"},{"location":"Preparation/#for-diy","text":"To DIY your own custom shape balloon envelop, we also recommend using Mylar as materials. To purchase Mylar, we recommend this Mylar sheet For manufacturing blimp envelop, please check Hardware manufacture","title":"For DIY"},{"location":"Preparation/#2-propulsion-system","text":"For propulsion system, we will try motor+propellers as propulsion solution. You need to prepare the following items: Motors (Both DC or brushless motors would work) For brushless motors, you also need ESC( Electric Speed Controller ) Propellers Motor drivers Here are some examples (different DC motors and propellers combinations): As listed above, the propellers should be compatible with your motor. Here are some links:","title":"2 Propulsion system"},{"location":"Preparation/#3-control-system","text":"For control system, we have multiple options for users to decide: NodeMCU ESP8266 Feather board ESP32 Raspberry Pi Zero W","title":"3 Control system"},{"location":"Preparation/#4-support-structure","text":"The support structure is for holding all the electronics in their positions. There are two different set of support structure, the first one is the most common one: 3D printed support, and the second one is another form: origami structure. For both 3D-printed structure and origami structure. We provide all their design files for users to print and use for their own blimp. 3D-printed support structure files Origami support structure files","title":"4 Support structure"},{"location":"Preparation/#5-battery-and-payloads","text":"The battery are critical to the blimp system and often times it can also be considered as one of the payloads on blimp. Something to notice for purchasing batteries: It should be small and light enough It should have big enough current output To understand more knowledge about batteries, please check the link Here are some links for batteries that we recommended: 450mhA batteries","title":"5 Battery and Payloads"},{"location":"Quick_start/","text":"Quick Start Requirements To get started, the following requirements should be fulfilled. Python Python3.7 or higher version is required for full functions. Installation First, download OpenBlimp github to your local folder if you haven\u2019t done it. To clone repository: git clone https://github.com/zhz03/OpenBlimp.git cd OpenBlimp Make sure you are in the root dir of OpenCDA, and next let\u2019s install the dependencies. We highly recommend use conda environment to install. conda env create -f environment.yml conda activate openblimp If conda install failed, install through pip: pip install -r requirements.txt Code Structure root \u251c\u2500\u2500\u2500docs \u2502 \u251c\u2500\u2500\u2500Demo \u2502 \u2514\u2500\u2500\u2500javascripts \u251c\u2500\u2500\u2500Hardware \u2502 \u251c\u2500\u2500\u25003d_design \u2502 \u2502 \u2514\u2500\u2500\u2500origami structure \u2502 \u251c\u2500\u2500\u2500circuit_plot_doc \u2502 \u2514\u2500\u2500\u2500Images \u2502 \u251c\u2500\u2500\u2500assembly \u2502 \u251c\u2500\u2500\u2500cases \u2502 \u251c\u2500\u2500\u2500motor_propellers \u2502 \u251c\u2500\u2500\u2500prepare \u2502 \u2514\u2500\u2500\u2500sensors \u251c\u2500\u2500\u2500imgs \u2514\u2500\u2500\u2500openblimp \u251c\u2500\u2500\u2500auto_control \u251c\u2500\u2500\u2500basic_control \u251c\u2500\u2500\u2500Images \u2502 \u2514\u2500\u2500\u2500communication \u2514\u2500\u2500\u2500manual_control \u2514\u2500\u2500\u2500arduino_code Note: Hardware directory contains all the hardware files like: 3D design files, hardware images, other hardware related files openblimp directory contains all the software files and code.","title":"Quick Start"},{"location":"Quick_start/#quick-start","text":"","title":"Quick Start"},{"location":"Quick_start/#requirements","text":"To get started, the following requirements should be fulfilled. Python Python3.7 or higher version is required for full functions.","title":"Requirements"},{"location":"Quick_start/#installation","text":"First, download OpenBlimp github to your local folder if you haven\u2019t done it. To clone repository: git clone https://github.com/zhz03/OpenBlimp.git cd OpenBlimp Make sure you are in the root dir of OpenCDA, and next let\u2019s install the dependencies. We highly recommend use conda environment to install. conda env create -f environment.yml conda activate openblimp If conda install failed, install through pip: pip install -r requirements.txt","title":"Installation"},{"location":"Quick_start/#code-structure","text":"root \u251c\u2500\u2500\u2500docs \u2502 \u251c\u2500\u2500\u2500Demo \u2502 \u2514\u2500\u2500\u2500javascripts \u251c\u2500\u2500\u2500Hardware \u2502 \u251c\u2500\u2500\u25003d_design \u2502 \u2502 \u2514\u2500\u2500\u2500origami structure \u2502 \u251c\u2500\u2500\u2500circuit_plot_doc \u2502 \u2514\u2500\u2500\u2500Images \u2502 \u251c\u2500\u2500\u2500assembly \u2502 \u251c\u2500\u2500\u2500cases \u2502 \u251c\u2500\u2500\u2500motor_propellers \u2502 \u251c\u2500\u2500\u2500prepare \u2502 \u2514\u2500\u2500\u2500sensors \u251c\u2500\u2500\u2500imgs \u2514\u2500\u2500\u2500openblimp \u251c\u2500\u2500\u2500auto_control \u251c\u2500\u2500\u2500basic_control \u251c\u2500\u2500\u2500Images \u2502 \u2514\u2500\u2500\u2500communication \u2514\u2500\u2500\u2500manual_control \u2514\u2500\u2500\u2500arduino_code Note: Hardware directory contains all the hardware files like: 3D design files, hardware images, other hardware related files openblimp directory contains all the software files and code.","title":"Code Structure"},{"location":"Sensors/","text":"Vision sensors 1. FPV Cam 2. Esp32 Cam 3. Esp Eye 4. OpenMV Cam 5. Nicla Vision","title":"Sensors"},{"location":"Sensors/#vision-sensors","text":"","title":"Vision sensors"},{"location":"Sensors/#1-fpv-cam","text":"","title":"1. FPV Cam"},{"location":"Sensors/#2-esp32-cam","text":"","title":"2. Esp32 Cam"},{"location":"Sensors/#3-esp-eye","text":"","title":"3. Esp Eye"},{"location":"Sensors/#4-openmv-cam","text":"","title":"4. OpenMV Cam"},{"location":"Sensors/#5-nicla-vision","text":"","title":"5. Nicla Vision"},{"location":"Software/","text":"Software Manual control Autonomous control","title":"Software"},{"location":"Software/#software","text":"","title":"Software"},{"location":"Software/#manual-control","text":"","title":"Manual control"},{"location":"Software/#autonomous-control","text":"","title":"Autonomous control"},{"location":"To_be_continue/","text":"Arrangement Jobs: 1 JJ ESP_eye both software and hardware(alternative) OpenMV esp32 cam Nicla vision 2 Jill Manual Control Autonomous Control 3 Yogi Hardware manufacture Auto control Update and meeting time: Tuesday 8:30pm Everyweek All the resources: Go Pro videos from April 2021\u2019s competition General photos and videos from the previous competition: DRONES - Google Drive Blimp joystick control Blimp modelling git: GitHub - zhz03/209_project_Blimp_modelling Blimp design resource: Jiahao Li / foray \u00b7 GitLab (uclalemur.com) Summer 2021 blimp autonomy git: Arnhold / Blimp Autonomy \u00b7 GitLab (uclalemur.com) Aaron\u2019s drive for visual processing of green balloon: Color Segmentation - ECE 209: Blimp project - Google Drive Aaron\u2019s Git repository for visual processing of green balloon (with final PyTorch code): Aaron John Sabu / FORAY-Ball-Detection \u00b7 GitLab (uclalemur.com) LEMUR_FPV_camera_blimp Using joystick to control multiple blimps Ankur and engineers modified blimp control version in April competition","title":"To be continue"},{"location":"To_be_continue/#arrangement","text":"","title":"Arrangement"},{"location":"To_be_continue/#jobs","text":"","title":"Jobs:"},{"location":"To_be_continue/#1-jj","text":"ESP_eye both software and hardware(alternative) OpenMV esp32 cam Nicla vision","title":"1 JJ"},{"location":"To_be_continue/#2-jill","text":"Manual Control Autonomous Control","title":"2 Jill"},{"location":"To_be_continue/#3-yogi","text":"Hardware manufacture Auto control","title":"3 Yogi"},{"location":"To_be_continue/#update-and-meeting-time","text":"Tuesday 8:30pm Everyweek","title":"Update and meeting time:"},{"location":"To_be_continue/#all-the-resources","text":"Go Pro videos from April 2021\u2019s competition General photos and videos from the previous competition: DRONES - Google Drive Blimp joystick control Blimp modelling git: GitHub - zhz03/209_project_Blimp_modelling Blimp design resource: Jiahao Li / foray \u00b7 GitLab (uclalemur.com) Summer 2021 blimp autonomy git: Arnhold / Blimp Autonomy \u00b7 GitLab (uclalemur.com) Aaron\u2019s drive for visual processing of green balloon: Color Segmentation - ECE 209: Blimp project - Google Drive Aaron\u2019s Git repository for visual processing of green balloon (with final PyTorch code): Aaron John Sabu / FORAY-Ball-Detection \u00b7 GitLab (uclalemur.com) LEMUR_FPV_camera_blimp Using joystick to control multiple blimps Ankur and engineers modified blimp control version in April competition","title":"All the resources:"},{"location":"UserInterface/","text":"User interface Introduction Our user interface is using Blynk app for any users who have cellphone to download. Blynk platform powers low-batch manufacturers of smart home products, complex HVAC systems, agricultural equipment, and everyone in between. Installation To download Blynk mobile app, please check their website Blimp control interface Our recommended Blynk interface is shown as below: You can also customize your own interface as long as you have the following functionality: Control panel : your control panel should include two joystick and one slider to give you the ability to control motion primitives(horizontal, vertical and rotation) and all motor propellers speed. Configuration commands : this will be the terminal widgets in the Blynk. This is for sending to correct configuration commands to configure the hardware mapping. \u200b","title":"User interface"},{"location":"UserInterface/#user-interface","text":"","title":"User interface"},{"location":"UserInterface/#introduction","text":"Our user interface is using Blynk app for any users who have cellphone to download. Blynk platform powers low-batch manufacturers of smart home products, complex HVAC systems, agricultural equipment, and everyone in between.","title":"Introduction"},{"location":"UserInterface/#installation","text":"To download Blynk mobile app, please check their website","title":"Installation"},{"location":"UserInterface/#blimp-control-interface","text":"Our recommended Blynk interface is shown as below: You can also customize your own interface as long as you have the following functionality: Control panel : your control panel should include two joystick and one slider to give you the ability to control motion primitives(horizontal, vertical and rotation) and all motor propellers speed. Configuration commands : this will be the terminal widgets in the Blynk. This is for sending to correct configuration commands to configure the hardware mapping. \u200b","title":"Blimp control interface"},{"location":"auto_control/","text":"Template!","title":"Autonomous Control"},{"location":"auto_control/#template","text":"","title":"Template!"},{"location":"logic_flow/","text":"Introduction and logic flow To build your own blimp, you need to follow the logic flow below: Note: For hardware preparation, please check previous Preparation . For blimp assembly, you need to follow the Design Principle . For hardware and control mapping, please take a look at Hardware Mapping . For Blynk App User interface, please find more details in User Interface . For advanced users and developers who want to extend the capability of their blimp, we also have guidance in Developer Tutorial .","title":"Logic Flow"},{"location":"logic_flow/#introduction-and-logic-flow","text":"To build your own blimp, you need to follow the logic flow below: Note: For hardware preparation, please check previous Preparation . For blimp assembly, you need to follow the Design Principle . For hardware and control mapping, please take a look at Hardware Mapping . For Blynk App User interface, please find more details in User Interface . For advanced users and developers who want to extend the capability of their blimp, we also have guidance in Developer Tutorial .","title":"Introduction and logic flow"},{"location":"resources/","text":"Previous resources This list is sorted in Reverse Chronological Order: blimp repo in November 2021 competition November 2021 Blimp Competition Visual processing PyTorch code of green balloon Blimp modelling git Blimp previous design git Blimp joystick control git","title":"Previous resources"},{"location":"resources/#previous-resources","text":"This list is sorted in Reverse Chronological Order: blimp repo in November 2021 competition November 2021 Blimp Competition Visual processing PyTorch code of green balloon Blimp modelling git Blimp previous design git Blimp joystick control git","title":"Previous resources"},{"location":"Demo/Flying_test/","text":"DEMO: Flying tests Flying test: Feather board ESP32 Control blimp to move forward: Another angle of view: Flying test of turning: Goal detection The goal detection vertical flying test: The goal detection horizontal flying test: The goal detection hovering flying test: Hovering The blimp can hover when it's close to the goal if we set PID value to be small: The blimp will easily lose track of the goal when it approaches from a further distance because our PID value is small: A screen recording shows how it lost track of the goal: High level integrated logic test Full integrated high level logic flying test:","title":"Flying Tests"},{"location":"Demo/Flying_test/#demo-flying-tests","text":"","title":"DEMO: Flying tests"},{"location":"Demo/Flying_test/#flying-test-feather-board-esp32","text":"Control blimp to move forward: Another angle of view: Flying test of turning:","title":"Flying test: Feather board ESP32"},{"location":"Demo/Flying_test/#goal-detection","text":"The goal detection vertical flying test: The goal detection horizontal flying test: The goal detection hovering flying test:","title":"Goal detection"},{"location":"Demo/Flying_test/#hovering","text":"The blimp can hover when it's close to the goal if we set PID value to be small: The blimp will easily lose track of the goal when it approaches from a further distance because our PID value is small: A screen recording shows how it lost track of the goal:","title":"Hovering"},{"location":"Demo/Flying_test/#high-level-integrated-logic-test","text":"Full integrated high level logic flying test:","title":"High level integrated logic test"},{"location":"Demo/Sensors/","text":"DEMO: Sensors","title":"DEMO: Sensors"},{"location":"Demo/Sensors/#demo-sensors","text":"","title":"DEMO: Sensors"},{"location":"Demo/Unit_tests/","text":"DEMO: Unit tests Test two esp32-cam running at the same time The first line are the individual tests for a single esp32 cam connecting to the router. The second line is two esp32-cam connecting to the router and running at the same time: Configure the motor setup using input commands ESP32 Cam detecting green ball Two-way communication between two ESP32 chip We finished the two-way wifi communication between two esp32. Based on our experiment two days ago, in order to easily and quickly debug our PID paramters. We need to find a good way to tune those parameters and receive the information from the blimp for debugging purposes. In the following video, we have two esp32 feather boards. The left one is the master board and the right one is the slave board. We setup a two-way communication through peer-to-peer WiFi. How to use this? (1) Debugging purpose via sending back the infomation (2) Tunning paramters via sending the commands to the blimp (3) Transmit ML algorithm output to the slave board Test live video from ESP32CAM with ML color detection and color threshold methods The color threshold algorithm was tested on the live video from ESP32-cam: This is the demo with low resolution: This is the demo with high resolution:","title":"Unit Test"},{"location":"Demo/Unit_tests/#demo-unit-tests","text":"","title":"DEMO: Unit tests"},{"location":"Demo/Unit_tests/#test-two-esp32-cam-running-at-the-same-time","text":"The first line are the individual tests for a single esp32 cam connecting to the router. The second line is two esp32-cam connecting to the router and running at the same time:","title":"Test two esp32-cam running at the same time"},{"location":"Demo/Unit_tests/#configure-the-motor-setup-using-input-commands","text":"","title":"Configure the motor setup using input commands"},{"location":"Demo/Unit_tests/#esp32-cam-detecting-green-ball","text":"","title":"ESP32 Cam detecting green ball"},{"location":"Demo/Unit_tests/#two-way-communication-between-two-esp32-chip","text":"We finished the two-way wifi communication between two esp32. Based on our experiment two days ago, in order to easily and quickly debug our PID paramters. We need to find a good way to tune those parameters and receive the information from the blimp for debugging purposes. In the following video, we have two esp32 feather boards. The left one is the master board and the right one is the slave board. We setup a two-way communication through peer-to-peer WiFi. How to use this? (1) Debugging purpose via sending back the infomation (2) Tunning paramters via sending the commands to the blimp (3) Transmit ML algorithm output to the slave board","title":"Two-way communication between two ESP32 chip"},{"location":"Demo/Unit_tests/#test-live-video-from-esp32cam-with-ml-color-detection-and-color-threshold-methods","text":"The color threshold algorithm was tested on the live video from ESP32-cam: This is the demo with low resolution: This is the demo with high resolution:","title":"Test live video from ESP32CAM  with ML color detection and color threshold methods"}]}